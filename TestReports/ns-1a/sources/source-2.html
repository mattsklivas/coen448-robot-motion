


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > DefaultArgumentConverter</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.junit.jupiter.params.converter</a>
</div>

<h1>Coverage Summary for Class: DefaultArgumentConverter (org.junit.jupiter.params.converter)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">DefaultArgumentConverter</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (3/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    14.3%
  </span>
  <span class="absValue">
    (2/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    24%
  </span>
  <span class="absValue">
    (6/25)
  </span>
</td>
</tr>
  <tr>
    <td class="name">DefaultArgumentConverter$StringToCommonJavaTypesConverter</td>
<td class="coverageStat">
  <span class="percent">
    37.5%
  </span>
  <span class="absValue">
    (3/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    58.3%
  </span>
  <span class="absValue">
    (14/24)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultArgumentConverter$StringToEnumConverter</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultArgumentConverter$StringToJavaTimeConverter</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    89.5%
  </span>
  <span class="absValue">
    (17/19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultArgumentConverter$StringToObjectConverter</td>
  </tr>
  <tr>
    <td class="name">DefaultArgumentConverter$StringToPrimitiveConverter</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (2/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    73.3%
  </span>
  <span class="absValue">
    (11/15)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    42.3%
  </span>
  <span class="absValue">
    (11/26)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    12.5%
  </span>
  <span class="absValue">
    (2/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    56.3%
  </span>
  <span class="absValue">
    (49/87)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;//
&nbsp;// Source code recreated from a .class file by IntelliJ IDEA
&nbsp;// (powered by FernFlower decompiler)
&nbsp;//
&nbsp;
&nbsp;package org.junit.jupiter.params.converter;
&nbsp;
&nbsp;import java.io.File;
&nbsp;import java.math.BigDecimal;
&nbsp;import java.math.BigInteger;
&nbsp;import java.net.MalformedURLException;
&nbsp;import java.net.URI;
&nbsp;import java.net.URL;
&nbsp;import java.nio.charset.Charset;
&nbsp;import java.nio.file.Path;
&nbsp;import java.nio.file.Paths;
&nbsp;import java.time.Duration;
&nbsp;import java.time.Instant;
&nbsp;import java.time.LocalDate;
&nbsp;import java.time.LocalDateTime;
&nbsp;import java.time.LocalTime;
&nbsp;import java.time.MonthDay;
&nbsp;import java.time.OffsetDateTime;
&nbsp;import java.time.OffsetTime;
&nbsp;import java.time.Period;
&nbsp;import java.time.Year;
&nbsp;import java.time.YearMonth;
&nbsp;import java.time.ZoneId;
&nbsp;import java.time.ZoneOffset;
&nbsp;import java.time.ZonedDateTime;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Currency;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Locale;
&nbsp;import java.util.Map;
&nbsp;import java.util.Optional;
&nbsp;import java.util.UUID;
&nbsp;import java.util.function.Function;
&nbsp;import org.apiguardian.api.API;
&nbsp;import org.apiguardian.api.API.Status;
&nbsp;import org.junit.platform.commons.util.Preconditions;
&nbsp;import org.junit.platform.commons.util.ReflectionUtils;
&nbsp;
&nbsp;@API(
&nbsp;    status = Status.INTERNAL,
&nbsp;    since = &quot;5.0&quot;
&nbsp;)
&nbsp;public class DefaultArgumentConverter extends SimpleArgumentConverter {
&nbsp;    public static final DefaultArgumentConverter INSTANCE = new DefaultArgumentConverter();
&nbsp;    private static final List&lt;StringToObjectConverter&gt; stringToObjectConverters = Collections.unmodifiableList(Arrays.asList(new StringToPrimitiveConverter(), new StringToEnumConverter(), new StringToJavaTimeConverter(), new StringToCommonJavaTypesConverter(), new FallbackStringToObjectConverter()));
&nbsp;
&nbsp;    private DefaultArgumentConverter() {
&nbsp;    }
&nbsp;
&nbsp;    public Object convert(Object source, Class&lt;?&gt; targetType) {
&nbsp;        if (source == null) {
&nbsp;            if (targetType.isPrimitive()) {
&nbsp;                throw new ArgumentConversionException(&quot;Cannot convert null to primitive value of type &quot; + targetType.getName());
&nbsp;            } else {
&nbsp;                return null;
&nbsp;            }
&nbsp;        } else {
&nbsp;            return ReflectionUtils.isAssignableTo(source, targetType) ? source : this.convertToTargetType(source, toWrapperType(targetType));
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private Object convertToTargetType(Object source, Class&lt;?&gt; targetType) {
&nbsp;        if (source instanceof String) {
&nbsp;            Optional&lt;StringToObjectConverter&gt; converter = stringToObjectConverters.stream().filter((candidate) -&gt; {
&nbsp;                return candidate.canConvert(targetType);
&nbsp;            }).findFirst();
&nbsp;            if (converter.isPresent()) {
&nbsp;                try {
<b class="fc">&nbsp;                    return ((StringToObjectConverter)converter.get()).convert((String)source, targetType);</b>
&nbsp;                } catch (Exception var5) {
<b class="fc">&nbsp;                    if (var5 instanceof ArgumentConversionException) {</b>
&nbsp;                        throw (ArgumentConversionException)var5;
&nbsp;                    }
&nbsp;
&nbsp;                    throw new ArgumentConversionException(&quot;Failed to convert String \&quot;&quot; + source + &quot;\&quot; to type &quot; + targetType.getName(), var5);
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        throw new ArgumentConversionException(&quot;No implicit conversion to convert object of type &quot; + source.getClass().getName() + &quot; to type &quot; + targetType.getName());
&nbsp;    }
&nbsp;
&nbsp;    private static Class&lt;?&gt; toWrapperType(Class&lt;?&gt; targetType) {
&nbsp;        Class&lt;?&gt; wrapperType = ReflectionUtils.getWrapperType(targetType);
<b class="pc">&nbsp;        return wrapperType != null ? wrapperType : targetType;</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    private static class StringToCommonJavaTypesConverter implements StringToObjectConverter {</b>
&nbsp;        private static final Map&lt;Class&lt;?&gt;, Function&lt;String, ?&gt;&gt; CONVERTERS;
<b class="nc">&nbsp;</b>
&nbsp;        private StringToCommonJavaTypesConverter() {
&nbsp;        }
<b class="pc">&nbsp;</b>
<b class="fc">&nbsp;        public boolean canConvert(Class&lt;?&gt; targetType) {</b>
&nbsp;            return CONVERTERS.containsKey(targetType);
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        public Object convert(String source, Class&lt;?&gt; targetType) throws Exception {
&nbsp;            return ((Function)CONVERTERS.get(targetType)).apply(source);
&nbsp;        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        private static Class&lt;?&gt; toClass(String type) {</b>
<b class="nc">&nbsp;            return (Class)ReflectionUtils.tryToLoadClass(type).getOrThrow((cause) -&gt; {</b>
<b class="nc">&nbsp;                return new ArgumentConversionException(&quot;Failed to convert String \&quot;&quot; + type + &quot;\&quot; to type &quot; + Class.class.getName(), cause);</b>
&nbsp;            });
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        private static URL toURL(String url) {</b>
<b class="nc">&nbsp;            try {</b>
&nbsp;                return new URL(url);
<b class="nc">&nbsp;            } catch (MalformedURLException var2) {</b>
&nbsp;                throw new ArgumentConversionException(&quot;Failed to convert String \&quot;&quot; + url + &quot;\&quot; to type &quot; + URL.class.getName(), var2);
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
&nbsp;        static {
&nbsp;            Map&lt;Class&lt;?&gt;, Function&lt;String, ?&gt;&gt; converters = new HashMap();
&nbsp;            converters.put(Class.class, StringToCommonJavaTypesConverter::toClass);
<b class="nc">&nbsp;            converters.put(File.class, File::new);</b>
<b class="nc">&nbsp;            converters.put(Charset.class, Charset::forName);</b>
&nbsp;            converters.put(Path.class, (x$0) -&gt; {
&nbsp;                return Paths.get(x$0);
&nbsp;            });
<b class="nc">&nbsp;            converters.put(URI.class, URI::create);</b>
<b class="nc">&nbsp;            converters.put(URL.class, StringToCommonJavaTypesConverter::toURL);</b>
&nbsp;            converters.put(BigDecimal.class, BigDecimal::new);
&nbsp;            converters.put(BigInteger.class, BigInteger::new);
&nbsp;            converters.put(Currency.class, Currency::getInstance);
&nbsp;            converters.put(Locale.class, Locale::new);
&nbsp;            converters.put(UUID.class, UUID::fromString);
&nbsp;            CONVERTERS = Collections.unmodifiableMap(converters);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static class StringToJavaTimeConverter implements StringToObjectConverter {
<b class="fc">&nbsp;        private static final Map&lt;Class&lt;?&gt;, Function&lt;String, ?&gt;&gt; CONVERTERS;</b>
&nbsp;
&nbsp;        private StringToJavaTimeConverter() {
&nbsp;        }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        public boolean canConvert(Class&lt;?&gt; targetType) {</b>
<b class="fc">&nbsp;            return CONVERTERS.containsKey(targetType);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
&nbsp;        public Object convert(String source, Class&lt;?&gt; targetType) throws Exception {
<b class="fc">&nbsp;            return ((Function)CONVERTERS.get(targetType)).apply(source);</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        static {</b>
<b class="fc">&nbsp;            Map&lt;Class&lt;?&gt;, Function&lt;String, ?&gt;&gt; converters = new HashMap();</b>
<b class="fc">&nbsp;            converters.put(Duration.class, Duration::parse);</b>
<b class="fc">&nbsp;            converters.put(Instant.class, Instant::parse);</b>
&nbsp;            converters.put(LocalDate.class, LocalDate::parse);
&nbsp;            converters.put(LocalDateTime.class, LocalDateTime::parse);
&nbsp;            converters.put(LocalTime.class, LocalTime::parse);
&nbsp;            converters.put(MonthDay.class, MonthDay::parse);
<b class="nc">&nbsp;            converters.put(OffsetDateTime.class, OffsetDateTime::parse);</b>
&nbsp;            converters.put(OffsetTime.class, OffsetTime::parse);
&nbsp;            converters.put(Period.class, Period::parse);
&nbsp;            converters.put(Year.class, Year::parse);
&nbsp;            converters.put(YearMonth.class, YearMonth::parse);
<b class="nc">&nbsp;            converters.put(ZonedDateTime.class, ZonedDateTime::parse);</b>
&nbsp;            converters.put(ZoneId.class, ZoneId::of);
&nbsp;            converters.put(ZoneOffset.class, ZoneOffset::of);
&nbsp;            CONVERTERS = Collections.unmodifiableMap(converters);
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private static class StringToEnumConverter implements StringToObjectConverter {
<b class="nc">&nbsp;        private StringToEnumConverter() {</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean canConvert(Class&lt;?&gt; targetType) {
&nbsp;            return targetType.isEnum();
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        public Object convert(String source, Class&lt;?&gt; targetType) throws Exception {
&nbsp;            return this.valueOf(targetType, source);
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        private Object valueOf(Class targetType, String source) {
&nbsp;            return Enum.valueOf(targetType, source);
&nbsp;        }
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    private static class StringToPrimitiveConverter implements StringToObjectConverter {
&nbsp;        private static final Map&lt;Class&lt;?&gt;, Function&lt;String, ?&gt;&gt; CONVERTERS;
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        private StringToPrimitiveConverter() {</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        public boolean canConvert(Class&lt;?&gt; targetType) {</b>
<b class="fc">&nbsp;            return CONVERTERS.containsKey(targetType);</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        public Object convert(String source, Class&lt;?&gt; targetType) {</b>
<b class="fc">&nbsp;            return ((Function)CONVERTERS.get(targetType)).apply(source);</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        static {</b>
<b class="fc">&nbsp;            Map&lt;Class&lt;?&gt;, Function&lt;String, ?&gt;&gt; converters = new HashMap();</b>
<b class="fc">&nbsp;            converters.put(Boolean.class, Boolean::valueOf);</b>
<b class="fc">&nbsp;            converters.put(Character.class, (source) -&gt; {</b>
&nbsp;                Preconditions.condition(source.length() == 1, () -&gt; {
&nbsp;                    return &quot;String must have length of 1: &quot; + source;
&nbsp;                });
&nbsp;                return source.charAt(0);
<b class="nc">&nbsp;            });</b>
&nbsp;            converters.put(Byte.class, Byte::decode);
&nbsp;            converters.put(Short.class, Short::decode);
&nbsp;            converters.put(Integer.class, Integer::decode);
&nbsp;            converters.put(Long.class, Long::decode);
<b class="nc">&nbsp;            converters.put(Float.class, Float::valueOf);</b>
&nbsp;            converters.put(Double.class, Double::valueOf);
&nbsp;            CONVERTERS = Collections.unmodifiableMap(converters);
&nbsp;        }
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    interface StringToObjectConverter {
&nbsp;        boolean canConvert(Class&lt;?&gt; var1);
&nbsp;
<b class="fc">&nbsp;        Object convert(String var1, Class&lt;?&gt; var2) throws Exception;</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-02-23 22:04</div>
</div>
</body>
</html>
